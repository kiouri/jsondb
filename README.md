# Назначение решения
Данный проект решает задачу автоматического парсинга json-структур (файлов) и перенос содержащихся в них данных в таблицы реляционной БД. Структура БД формируется автоматически на основе анализа
Каких-либо ограничений на структуры обрабатываемых json’ов не накладывается.

Вся специфика, связанначя с использованием разных БД, касающаяся правил формирования наименований (таблиц, столбцов, FK и пр.) и синтаксиса DDL утверждений инкапсулирована в отдельных компонентах решения. В настоящее время в качестве “эталонной” реализации поддерживается работа с БД PostgreSQL. При необходимости решение может быть адаптировано к использованию любой другой БД, посредством реализации нескольких несложных интерфейсов.

Решение решение может быть использовано как для однократной загрузки в БД Json-файла, так и для регулярной загрузки файлов сходной структуры (например, в озеро данных). Если от загрузки к загрузке структура файлов несколько изменяется, то такие изменения будут обработаны автоматически таким образом, что обновленная структура БД будет сопоставима с ее предыдущими версиями.

Json объекты трансформируются в реляционные таблицы, а входящие в состав объектов пары ключ-значение определяют структуру таблиц. Если значением какого-то ключа является объект, то формируется еще одна таблица и т.д. Таблицы связываются между собой посредством добавления специализированных полей, позволяющих реализовать связи вида “один-ко-многим”. Эта связь хорошо подходит для json-структур, поскольку каждый вложенный объект имеет не более одного родительского объекта и может содержать неограниченное число вложенных объектов.

Если вложенные объекты объединены в массив, то каждый элемент массива анализируется на предмет его структуры. Для всех элементов массива, имеющих общую структуру.

# Общее описание реализации
Генерация структуры таблиц
Json объекты трансформируются в реляционные таблицы, а входящие в состав объектов пары ключ-значение определяют структуру таблиц. Если значением какого-то ключа является объект, то формируется еще одна таблица и т.д. Таблицы связываются между собой посредством добавления специализированных полей, позволяющих реализовать связи вида “один-ко-многим”. Эта связь хорошо подходит для json-структур, поскольку каждый вложенный объект имеет не более одного родительского объекта и может содержать неограниченное число вложенных объектов.

Если вложенные объекты объединены в массив, то каждый элемент массива анализируется на предмет его структуры. Для всех элементов массива, имеющих общую структуру создается единственная таблица.

На основе анализа Json файла формируется еще один json фаайл, описывающий структуру БД, куда будут помещены данные. Этот файл содержит массив объектов, которые связывают таблицы БД с тегами исходного json файла. Каждый элемент этого массива содержит пути к тегу исходного файла, наименование таблицы, куда будут помещены данные этого объекта, наименование родительской таблицы, список ключей объекта и соответствующих им полей в таблице. В каждую таблицу вставляется три дополнительных поля

iiiddd – глобально уникальный идентификатор строки в таблице.

parent_iiiddd — идентификкатор родительской записи (в другой таблице)

job_iiiddd — идентификатор задания, выполневшего загрузку. Всем данным, гагруженным из одного файла будет присвоен одинаковый идентификатор задания.

Iiiddd и parent_iiiddd заполняются автоматически. Значение lkz job_iiiddd задается пользователем при инициализации новой процедуры загрузки.

Выглядит это так (пример для одного объекта):  
```
{"tag":  
{ 	"tagPath": ["root"],   
		"parentTAGSQLName": "",   
		"tagName": "root",  
		"sqlName": "root",  
		"attrs": [  
			{  
				"attrName": "iiiddd",  
				"attrSqlName": "iiiddd"  
			},  
			{ 	"attrName": "parent_iiiddd",  
				"attrSqlName": "parent_iiiddd"  
			},  
			{  
				"attrName": "job_iiiddd",  
				"attrSqlName": "job_iiiddd" 
			},  
			{ 
				"attrName": "dateUploadSession",
				"attrSqlName": "dateUploadSession" 
			}, 
			{ 
				"attrName": "addressee", 
				"attrSqlName": "addressee" 
			}, 
			{ 
				"attrName": "sender", 
				"attrSqlName": "sender" }, 
			{ 
				"attrName": "protocolVersion", 
				"attrSqlName": "protocolVersion" 
			}, 
			{ 
				"attrName": "dateSendingPackage",
				"attrSqlName": "dateSendingPackage" 
			} 
		] 
	}
}
```
Указанная выше структура, описывающая соответствие между тегами исходного json файла и таблицами БД сохраняется в файле, путь к которому указывает пользователь библиотеки. Файл можно отредактировать, поменяв названия таблици и их полей. Для того, что бы приследующей загррузке подобного файла данные изменения не потерялись, этот файл сохраняется и передается как параметр при очередной загрузке. Если, очередной json-файл содержит расширенный набор атрибутов по сравнению с предыдущей загрузкой, то они будут учтеныы, а выходной файл описывающий структур БД и ее связь со входным json’ом, будет являться объединением, как текущего, так и предыдущего описания.

# Генерация DDL утверждений для создания таблиц
Следующим шагом на основе json описания соответствия между объектами обрабатываемого файла и артефактами БД генерируются DDL утверждения, позволяющие создать таблицы БД. Эти DDL утверждения можно сохранить в файл или получить в виде строки. При этом гененрируются скрипты для создания таблиц и ограничений в виде внешних ключей. Скрипты генерируются тааким образом, что они корректно обрабатывают ситуацию, когда создаваемый объект уже есть в БД. Ошибок при этом не возникает, ранее созданные артефакты БД сохраняются.

# Генерация SQL утверждений для занесения данных в таблицы
Далее на основе исходного json файла c данными и json-файла, описывающего структуру таблиц создатся набор sql утверждений для добавления данных в таблицы. Эти sql утверждения можно получить в виде строки или сохранить в виде файла.

# Выполнение DDL/SQL утверждений
Проект, помимо описанного выше содержит модуль, позволяющий исполнять DDL/SQL скрипты. Для его использования требуется описать параметры подключения к бд в json файле следующей структуры:
```
{ 
	"host" : "localhost", 
	"port" : "5432", 
	"database" : "nafta", 
	"schema" : "public", 
	"user" : "postgres", 
	"password" : "Flshce155" 
}
```
# Примеры использования
В пакете com.kiouri.jsontodb.usagesamples содержаться примеры использования данного решения

## sample1

Этот пример является пошаговым, максимально детальным примером, описывающим работу с приложением и сохраняющим в виде файлов все описанные выше результаты.

## sample2

Этот пример является сокращенной версией предыдущего — промежуточные результаты в виде файлов не сохраняются.

## sample3

Этот пример показывает, как можно организовать обработку набора json файлов, расположенных в одной директории.

Внимание! После обработки файлы удаляются.

# Использование библиотеки
Библиотека доступна в исходных кодах. Для maven прооекта можно загрузить зависимости из центрального репозитория.
```
<dependency>
<groupId>io.github.kiouri</groupId>
<artifactId>jsondb</artifactId>
<version>0.0.1</version>
</dependency>
```

[maven central repository](https://search.maven.org/artifact/io.github.kiouri/jsondb/0.0.1/jar)